qipan = 10
#定义了一个变量 qipan，它表示棋盘的大小为 10，即棋盘是 10x10 的。
#Объявлена переменная qipan, которая задаёт размер доски как 10, то есть доска будет 10x10.
caozuo = [['.' for _ in range(qipan)] for _ in range(qipan)]  # 初始化棋盘
#这里用列表推导式创建了一个二维列表（10x10 的棋盘），每个位置都用 . 来表示。_ 是一个占位符，因为我们只需要循环次数，不需要具体的值。
#Здесь создаётся двумерный список (доска 10x10) с помощью list comprehension. Каждая клетка
# доски будет обозначена символом . как пустая. Символ _ используется как заглушка, поскольку
# нам важно только количество итераций, а не значение переменной.
for hang in caozuo:
    print(' '.join(hang))# .join表示的是叠次出现
print()
#遍历棋盘的每一行，并使用 ' '.join(hang) 将每一行的元素通过空格连接成一个字符串后输出，初始状态的棋盘会被打印出来。
#Проход по каждой строке доски, где используется ' '.join(hang), чтобы объединить элементы строки пробелом
# и вывести текущее состояние доски.
player = 1
#初始化 player 为 1，表示第一个玩家。
#Инициализация переменной player как 1, что означает, что первым ходит игрок 1.
while True:    # 游戏循环
    #开启了一个无限循环，直到游戏结束。
    #Открывается бесконечный цикл, который продолжается до конца игры.
    for hang in caozuo:  # 显示当前棋盘状态
        print(' '.join(hang))
    print()
#每次玩家输入坐标前，都会打印当前的棋盘状态。Перед каждым ходом игрока выводится текущее состояние доски.
    print(f"玩家(игрок) {player} 的回合:")
#提示当前是哪个玩家的回合。Выводится сообщение, чей сейчас ход (игрока 1 или 2).
    try:  # 请求玩家输入坐标x y
        x, y = map(int, input("请输入坐标(Пожалуйста, введите координаты) (行(x) 列(y)): ").split())
    except ValueError:
        print("输入无效，请输入两个整数。(Неверный ввод. Введите два целых числа.)")
        continue
#提示玩家输入两个整数作为坐标，使用 map 将输入的两个数字转换为整数。如果输入格式不正确
#程序会捕捉到 ValueError 异常并要求玩家重新输入。
#Запрашиваются координаты хода у игрока и преобразуются в целые числа с помощью map.
# Если введены неверные значения (не числа), выводится сообщение об ошибке и запрос повторяется.
    if not (0 <= x < qipan and 0 <= y < qipan and caozuo[x][y] == '.'):  # 检查输入是否合法
        print("无效的移动，位置超出范围或该格子已被占用，请重试。(Неверный ход, позиция вне диапазона или сетка занята, попробуйте еще раз.)")
        continue
#检查玩家输入的坐标是否合法：是否在棋盘范围内，并且该位置是否为空（用 . 表示）。如果条件不符合，提示输入无效，并让玩家重新输入。
#Проверяется, что введённые координаты находятся в пределах доски и что выбранная клетка пуста.
# Если проверка не пройдена, игроку предлагается ввести координаты заново.
    if player == 1:  # 依据玩家标记棋盘
        caozuo[x][y] = 'X'
    else:
        caozuo[x][y] = 'O'
#根据当前玩家是1还是2，将对应的棋盘位置标记为 ‘X’ 或 ‘O’。
#На основе текущего игрока (1 или 2) соответствующая клетка помечается символом ‘X’ или ‘O’.
    shuoming = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (1, 1), (-1, 1), (1, -1)]
    gameover = False          # 检查是否形成3个连续的标记（任意标记，不分玩家）
#定义 shuoming 变量，它包含八个方向（上下左右和四个对角线）。gameover 初始化为 False，用于检查游戏是否结束。
#Объявляется список shuoming, который содержит восемь направлений для проверки
# (вверх, вниз, влево, вправо и четыре диагонали). Переменная gameover используется для отслеживания конца игры.
    for dx, dy in shuoming:
        biaoji = 1  # 包含当前标记
#开始遍历八个方向，每次都会设置一个 biaoji 计数器，初始值为1，表示当前玩家刚刚标记了一个位置。
#Начинаем проверку по всем восьми направлениям. Переменная biaoji отслеживает количество
#одинаковых символов подряд и изначально равна 1 (считаем текущий ход игрока).
        # 向一个方向检查连续标记
        for i in range(1, 3):  # 只检查连续的2个格子，总共3个标记
            nx = x + i * dx
            ny = y + i * dy
            if (0 <= nx < qipan and
                    0 <= ny < qipan and
                    caozuo[nx][ny] != '.' and
                    caozuo[nx][ny] != '.'):
                biaoji += 1
            else:
                break
#在某个方向上，检查当前标记的相邻位置是否连续匹配。如果发现两个以上相邻位置是相同的（非 .），则将 biaoji 增加1。
#Проверяем два соседних поля в одном направлении, чтобы увидеть, образуют ли они последовательность
# с текущим ходом. Если найдены подряд идущие клетки с одинаковыми символами, счётчик увеличивается
        # 反方向检查(Обратная проверка нужна для того, чтобы убедиться, что проверяемая последовательность является полной, то есть есть ли подряд идущие одинаковые метки не только в одном направлении, но и в противоположном. Проверяя на наличие совпадений в обоих направлениях, можно точно определить, соблюдено ли правило трёх или более одинаковых меток подряд, чтобы ни одна из сторон не могла выстроить цепочку из трёх или более меток.)
        for i in range(1, 3):  # 反方向最多再查2个
            nx = x - i * dx
            ny = y - i * dy
            if (0 <= nx < qipan and
                    0 <= ny < qipan and
                    caozuo[nx][ny] != '.' and
                    caozuo[nx][ny] != '.'):
                biaoji += 1
            else:
                break
# 同样地，反方向也检查相邻的两个位置是否连续。
#Проводится аналогичная проверка в обратном направлении на соседние две клетки.
        if biaoji >= 3:  # 如果任意方向形成3个连续标记
            gameover = True
            break
#如果在任意方向发现了3个或以上连续的标记，则游戏结束。
#Если в каком-либо направлении найдено три или более одинаковых символа подряд, игра заканчивается.
    if gameover:
        for hang in caozuo:
            print(' '.join(hang))
        print(f"玩家(игрок) {player} 输了(lose)!")
        break
#如果形成了连续3个标记，打印当前棋盘状态并宣布该玩家输掉游戏，终止循环。
#Если обнаружена последовательность из трёх символов, выводится текущее состояние доски и
    # объявляется проигравший. После этого цикл завершается.
    if player == 1:           # 切换玩家
        player = 2
    else:
        player = 1
#如果游戏没有结束，切换玩家，player 在 1 和 2 之间轮换。
#Если игра не закончена, происходит смена игрока. Игроки меняются местами между 1 и 2.